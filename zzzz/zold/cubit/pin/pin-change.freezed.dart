// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'pin-change.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PinChangeStateTearOff {
  const _$PinChangeStateTearOff();

  _PinChangeState call(
      {String currentPin = '',
      String currentPinError = '',
      bool checkingCurrentPin = false,
      bool currentPinChecked = false,
      String newPin = '',
      String newPinError = '',
      bool newPinComplete = false,
      String confirmNewPin = '',
      String confirmNewPinError = '',
      bool savingNewPin = false}) {
    return _PinChangeState(
      currentPin: currentPin,
      currentPinError: currentPinError,
      checkingCurrentPin: checkingCurrentPin,
      currentPinChecked: currentPinChecked,
      newPin: newPin,
      newPinError: newPinError,
      newPinComplete: newPinComplete,
      confirmNewPin: confirmNewPin,
      confirmNewPinError: confirmNewPinError,
      savingNewPin: savingNewPin,
    );
  }
}

/// @nodoc
const $PinChangeState = _$PinChangeStateTearOff();

/// @nodoc
mixin _$PinChangeState {
  String get currentPin => throw _privateConstructorUsedError;
  String get currentPinError => throw _privateConstructorUsedError;
  bool get checkingCurrentPin => throw _privateConstructorUsedError;
  bool get currentPinChecked => throw _privateConstructorUsedError;
  String get newPin => throw _privateConstructorUsedError;
  String get newPinError => throw _privateConstructorUsedError;
  bool get newPinComplete => throw _privateConstructorUsedError;
  String get confirmNewPin => throw _privateConstructorUsedError;
  String get confirmNewPinError => throw _privateConstructorUsedError;
  bool get savingNewPin => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PinChangeStateCopyWith<PinChangeState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PinChangeStateCopyWith<$Res> {
  factory $PinChangeStateCopyWith(
          PinChangeState value, $Res Function(PinChangeState) then) =
      _$PinChangeStateCopyWithImpl<$Res>;
  $Res call(
      {String currentPin,
      String currentPinError,
      bool checkingCurrentPin,
      bool currentPinChecked,
      String newPin,
      String newPinError,
      bool newPinComplete,
      String confirmNewPin,
      String confirmNewPinError,
      bool savingNewPin});
}

/// @nodoc
class _$PinChangeStateCopyWithImpl<$Res>
    implements $PinChangeStateCopyWith<$Res> {
  _$PinChangeStateCopyWithImpl(this._value, this._then);

  final PinChangeState _value;
  // ignore: unused_field
  final $Res Function(PinChangeState) _then;

  @override
  $Res call({
    Object? currentPin = freezed,
    Object? currentPinError = freezed,
    Object? checkingCurrentPin = freezed,
    Object? currentPinChecked = freezed,
    Object? newPin = freezed,
    Object? newPinError = freezed,
    Object? newPinComplete = freezed,
    Object? confirmNewPin = freezed,
    Object? confirmNewPinError = freezed,
    Object? savingNewPin = freezed,
  }) {
    return _then(_value.copyWith(
      currentPin: currentPin == freezed
          ? _value.currentPin
          : currentPin // ignore: cast_nullable_to_non_nullable
              as String,
      currentPinError: currentPinError == freezed
          ? _value.currentPinError
          : currentPinError // ignore: cast_nullable_to_non_nullable
              as String,
      checkingCurrentPin: checkingCurrentPin == freezed
          ? _value.checkingCurrentPin
          : checkingCurrentPin // ignore: cast_nullable_to_non_nullable
              as bool,
      currentPinChecked: currentPinChecked == freezed
          ? _value.currentPinChecked
          : currentPinChecked // ignore: cast_nullable_to_non_nullable
              as bool,
      newPin: newPin == freezed
          ? _value.newPin
          : newPin // ignore: cast_nullable_to_non_nullable
              as String,
      newPinError: newPinError == freezed
          ? _value.newPinError
          : newPinError // ignore: cast_nullable_to_non_nullable
              as String,
      newPinComplete: newPinComplete == freezed
          ? _value.newPinComplete
          : newPinComplete // ignore: cast_nullable_to_non_nullable
              as bool,
      confirmNewPin: confirmNewPin == freezed
          ? _value.confirmNewPin
          : confirmNewPin // ignore: cast_nullable_to_non_nullable
              as String,
      confirmNewPinError: confirmNewPinError == freezed
          ? _value.confirmNewPinError
          : confirmNewPinError // ignore: cast_nullable_to_non_nullable
              as String,
      savingNewPin: savingNewPin == freezed
          ? _value.savingNewPin
          : savingNewPin // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$PinChangeStateCopyWith<$Res>
    implements $PinChangeStateCopyWith<$Res> {
  factory _$PinChangeStateCopyWith(
          _PinChangeState value, $Res Function(_PinChangeState) then) =
      __$PinChangeStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String currentPin,
      String currentPinError,
      bool checkingCurrentPin,
      bool currentPinChecked,
      String newPin,
      String newPinError,
      bool newPinComplete,
      String confirmNewPin,
      String confirmNewPinError,
      bool savingNewPin});
}

/// @nodoc
class __$PinChangeStateCopyWithImpl<$Res>
    extends _$PinChangeStateCopyWithImpl<$Res>
    implements _$PinChangeStateCopyWith<$Res> {
  __$PinChangeStateCopyWithImpl(
      _PinChangeState _value, $Res Function(_PinChangeState) _then)
      : super(_value, (v) => _then(v as _PinChangeState));

  @override
  _PinChangeState get _value => super._value as _PinChangeState;

  @override
  $Res call({
    Object? currentPin = freezed,
    Object? currentPinError = freezed,
    Object? checkingCurrentPin = freezed,
    Object? currentPinChecked = freezed,
    Object? newPin = freezed,
    Object? newPinError = freezed,
    Object? newPinComplete = freezed,
    Object? confirmNewPin = freezed,
    Object? confirmNewPinError = freezed,
    Object? savingNewPin = freezed,
  }) {
    return _then(_PinChangeState(
      currentPin: currentPin == freezed
          ? _value.currentPin
          : currentPin // ignore: cast_nullable_to_non_nullable
              as String,
      currentPinError: currentPinError == freezed
          ? _value.currentPinError
          : currentPinError // ignore: cast_nullable_to_non_nullable
              as String,
      checkingCurrentPin: checkingCurrentPin == freezed
          ? _value.checkingCurrentPin
          : checkingCurrentPin // ignore: cast_nullable_to_non_nullable
              as bool,
      currentPinChecked: currentPinChecked == freezed
          ? _value.currentPinChecked
          : currentPinChecked // ignore: cast_nullable_to_non_nullable
              as bool,
      newPin: newPin == freezed
          ? _value.newPin
          : newPin // ignore: cast_nullable_to_non_nullable
              as String,
      newPinError: newPinError == freezed
          ? _value.newPinError
          : newPinError // ignore: cast_nullable_to_non_nullable
              as String,
      newPinComplete: newPinComplete == freezed
          ? _value.newPinComplete
          : newPinComplete // ignore: cast_nullable_to_non_nullable
              as bool,
      confirmNewPin: confirmNewPin == freezed
          ? _value.confirmNewPin
          : confirmNewPin // ignore: cast_nullable_to_non_nullable
              as String,
      confirmNewPinError: confirmNewPinError == freezed
          ? _value.confirmNewPinError
          : confirmNewPinError // ignore: cast_nullable_to_non_nullable
              as String,
      savingNewPin: savingNewPin == freezed
          ? _value.savingNewPin
          : savingNewPin // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_PinChangeState implements _PinChangeState {
  const _$_PinChangeState(
      {this.currentPin = '',
      this.currentPinError = '',
      this.checkingCurrentPin = false,
      this.currentPinChecked = false,
      this.newPin = '',
      this.newPinError = '',
      this.newPinComplete = false,
      this.confirmNewPin = '',
      this.confirmNewPinError = '',
      this.savingNewPin = false});

  @JsonKey(defaultValue: '')
  @override
  final String currentPin;
  @JsonKey(defaultValue: '')
  @override
  final String currentPinError;
  @JsonKey(defaultValue: false)
  @override
  final bool checkingCurrentPin;
  @JsonKey(defaultValue: false)
  @override
  final bool currentPinChecked;
  @JsonKey(defaultValue: '')
  @override
  final String newPin;
  @JsonKey(defaultValue: '')
  @override
  final String newPinError;
  @JsonKey(defaultValue: false)
  @override
  final bool newPinComplete;
  @JsonKey(defaultValue: '')
  @override
  final String confirmNewPin;
  @JsonKey(defaultValue: '')
  @override
  final String confirmNewPinError;
  @JsonKey(defaultValue: false)
  @override
  final bool savingNewPin;

  @override
  String toString() {
    return 'PinChangeState(currentPin: $currentPin, currentPinError: $currentPinError, checkingCurrentPin: $checkingCurrentPin, currentPinChecked: $currentPinChecked, newPin: $newPin, newPinError: $newPinError, newPinComplete: $newPinComplete, confirmNewPin: $confirmNewPin, confirmNewPinError: $confirmNewPinError, savingNewPin: $savingNewPin)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PinChangeState &&
            (identical(other.currentPin, currentPin) ||
                const DeepCollectionEquality()
                    .equals(other.currentPin, currentPin)) &&
            (identical(other.currentPinError, currentPinError) ||
                const DeepCollectionEquality()
                    .equals(other.currentPinError, currentPinError)) &&
            (identical(other.checkingCurrentPin, checkingCurrentPin) ||
                const DeepCollectionEquality()
                    .equals(other.checkingCurrentPin, checkingCurrentPin)) &&
            (identical(other.currentPinChecked, currentPinChecked) ||
                const DeepCollectionEquality()
                    .equals(other.currentPinChecked, currentPinChecked)) &&
            (identical(other.newPin, newPin) ||
                const DeepCollectionEquality().equals(other.newPin, newPin)) &&
            (identical(other.newPinError, newPinError) ||
                const DeepCollectionEquality()
                    .equals(other.newPinError, newPinError)) &&
            (identical(other.newPinComplete, newPinComplete) ||
                const DeepCollectionEquality()
                    .equals(other.newPinComplete, newPinComplete)) &&
            (identical(other.confirmNewPin, confirmNewPin) ||
                const DeepCollectionEquality()
                    .equals(other.confirmNewPin, confirmNewPin)) &&
            (identical(other.confirmNewPinError, confirmNewPinError) ||
                const DeepCollectionEquality()
                    .equals(other.confirmNewPinError, confirmNewPinError)) &&
            (identical(other.savingNewPin, savingNewPin) ||
                const DeepCollectionEquality()
                    .equals(other.savingNewPin, savingNewPin)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(currentPin) ^
      const DeepCollectionEquality().hash(currentPinError) ^
      const DeepCollectionEquality().hash(checkingCurrentPin) ^
      const DeepCollectionEquality().hash(currentPinChecked) ^
      const DeepCollectionEquality().hash(newPin) ^
      const DeepCollectionEquality().hash(newPinError) ^
      const DeepCollectionEquality().hash(newPinComplete) ^
      const DeepCollectionEquality().hash(confirmNewPin) ^
      const DeepCollectionEquality().hash(confirmNewPinError) ^
      const DeepCollectionEquality().hash(savingNewPin);

  @JsonKey(ignore: true)
  @override
  _$PinChangeStateCopyWith<_PinChangeState> get copyWith =>
      __$PinChangeStateCopyWithImpl<_PinChangeState>(this, _$identity);
}

abstract class _PinChangeState implements PinChangeState {
  const factory _PinChangeState(
      {String currentPin,
      String currentPinError,
      bool checkingCurrentPin,
      bool currentPinChecked,
      String newPin,
      String newPinError,
      bool newPinComplete,
      String confirmNewPin,
      String confirmNewPinError,
      bool savingNewPin}) = _$_PinChangeState;

  @override
  String get currentPin => throw _privateConstructorUsedError;
  @override
  String get currentPinError => throw _privateConstructorUsedError;
  @override
  bool get checkingCurrentPin => throw _privateConstructorUsedError;
  @override
  bool get currentPinChecked => throw _privateConstructorUsedError;
  @override
  String get newPin => throw _privateConstructorUsedError;
  @override
  String get newPinError => throw _privateConstructorUsedError;
  @override
  bool get newPinComplete => throw _privateConstructorUsedError;
  @override
  String get confirmNewPin => throw _privateConstructorUsedError;
  @override
  String get confirmNewPinError => throw _privateConstructorUsedError;
  @override
  bool get savingNewPin => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$PinChangeStateCopyWith<_PinChangeState> get copyWith =>
      throw _privateConstructorUsedError;
}
